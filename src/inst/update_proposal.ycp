/**
 * Module:	update_proposal.ycp
 *
 * Author:	Arvin Schnell <arvin@suse.de>
 *
 * Purpose:	Let user choose update settings.
 */
{
    textdomain "update";

    import "HTML";
    import "Update";
    import "Mode";
    import "Language";
    import "Packages";
    import "PackageCallbacks";

    import "Installation";


    string func = (string) WFM::Args(0);
    map param = (map) WFM::Args(1);
    map <string, any> ret = $[];


    define void add_kernel_subpackage ()
    {
	list <list> provides = Pkg::PkgQueryProvides ("kernel");
	y2milestone ("provides: %1", provides);

	list <list> kernels = filter (list l, provides, {
	    return l[1]:`NONE == `BOTH || l[1]:`NONE == l[2]:`NONE;
	});

	if (size (kernels) != 1)
	    y2error ("not exactly one package provides tag kernel");

	string kernel = kernels[0,0]:"none";
	string kernel_nongpl = kernel + "-nongpl";

	if (Pkg::IsAvailable (kernel_nongpl))
	{
	    y2milestone ("adding kernel subpackage %1", kernel_nongpl);
	    Pkg::PkgInstall (kernel_nongpl);
	}
    }


    define void init_stuff ()
    {
	// initialize package manager
	if (true)
	{
	    UI::OpenDialog (`opt(`decorated),
			    // intermediate popup while initializing internal packagemanagement
			    `Label(_("Reading package information. One moment please...")));

	    Packages::Init (true);

	    UI::CloseDialog();
	}

	// initialize target
	if (true)
	{
	    PackageCallbacks::SetConvertDBCallbacks ();

	    Pkg::TargetInit (Installation::destdir, false);

	    Update::GetProductName ();
	}

	// connect target with package manager
	if (!Update::did_init1)
	{
	    Update::did_init1 = true;

	    Pkg::PkgReset ();

	    if (!Update::did_init2)
	    {
		Update::did_init2 = true;
		Update::ProposeSelection ();
	    }

	    if (Update::onlyUpdateInstalled)			// just consider already installed packages
	    {
		Pkg::SetSelection ("");				// -> don't select any additional selections
	    }
	    else						// update selections too
	    {
		Pkg::SetSelection (Update::selected_selection);	// -> set the base selection (minimal, default, ....)

		if (!Update::manual_interaction)
		{
		    // now compare installed (old) selections against available (new) selections
		    //  and set all selections which are installed (old) and available (new)
		    //  as 'to be installed' -> UI will show "to be updated" for these selections

		    list<string> available_addons = Pkg::GetSelections (`available, "");
		    list<string> installed_addons = Pkg::GetSelections (`installed, "");

		    foreach (string installed, installed_addons,
		    {
			if (contains (available_addons, installed))	// we have a newer selection for an installed one
			{
			    Pkg::SetSelection (installed);		// update this selection too (selection solving included)
			}
		    });
		}
	    }

	    Pkg::ActivateSelections ();					// now go through all selected selections and select their packages

	    list tmp1 = Pkg::PkgUpdateAll (Update::deleteOldPackages);
	    Update::affected_packages = tmp1[0]:0;
	    Update::unknown_packages = tmp1[1]:0;

	    add_kernel_subpackage ();

	    if (Pkg::PkgSolve (!Update::onlyUpdateInstalled))
		Update::solve_errors = 0;
	    else
		Update::solve_errors = Pkg::PkgSolveErrors ();
	}

    }


    if ( func == "MakeProposal" )
    {
	boolean force_reset      = param["force_reset"     ]:false;
	boolean language_changed = param["language_changed"]:false;

	// call some function that makes a proposal here:
	//
	// DummyMod::MakeProposal( force_reset );

	if (force_reset)
	{
	    Update::Reset ();

	    Update::did_init1 = false;
	}


	// Fill return map

	init_stuff ();

	if (true)
	{
	    list available_base_selections = Update::GetBaseSelections ();
	    if (size (available_base_selections) == 0)
	    {
		y2error ("No base selections available");
		// Can't find any software data, probably a installation media error
		// error message
		return $[ "warning" : _("Cannot read package data from installation media. Media error?"),
			  "warning_level" : `blocker,
			  "raw_proposal" : [] ];
	    }
	}

	if (Update::disallow_upgrade)
	{
	    if (false)		// FIXME
	    {
		return $[ "warning" : _("Updating to another version is not supported from the running system."),
			  "warning_level" : `fatal,
			  "raw_proposal" : [] ];
	    }
	}

	list<string> tmp = [];

	tmp = add (tmp, sformat (_("Update to %1"), Update::updateVersion["nameandversion"]:"?"));

	if (Update::onlyUpdateInstalled)
	{
	    // Proposal for backup during update
	    tmp = add (tmp, _("Only Update Installed Packages"));
	}
	else
	{
	    map selection_data = Pkg::SelectionData (Update::selected_selection);
	    string selection_summary = selection_data["summary"]:"error";

	    // Proposal for selection during update
	    tmp = add (tmp, sformat (_("Update Based on Selection \"%1\""),
				     selection_summary));
	}

	if (Update::deleteOldPackages)
	{
	    // Proposal for backup during update
	    tmp = add (tmp, _("Delete Old Packages"));
	}

	ret = $[ "preformatted_proposal" :
		 HTML::List (tmp)
	];
    }
    else if ( func == "AskUser" )
    {
	boolean has_next = param["has_next"]:false;

	// call some function that displays a user dialog
	// or a sequence of dialogs here:
	//
	// sequence = DummyMod::AskUser( has_next );

	symbol result = (symbol) WFM::CallFunction ("inst_update", [true, has_next]);

	if (result == `next)
	{
	    Update::did_init1 = false;
	}

	// Fill return map

	ret = $[ "workflow_sequence" : result ];
    }
    else if ( func == "Description" )
    {
	// Fill return map.
	//
	// Static values do just nicely here, no need to call a function.

	ret =
	    $[
	      // this is a heading
	      "rich_text_title"	:	_("Update Options"),
	      // this is a menu entry
	      "menu_title"	:	_("&Update Options"),
	      "id"		:	"update_stuff"
	    ];
    }

    return ret;
}

/**
 * Module: 	inst_backup.ycp
 *
 * Authors:	Stefan Schubert <schubi@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *
 * Purpose:	Ask the user for backups during the update.
 */

{
    textdomain "update";

    import "Arch";
    import "Mode";
    import "Installation";
    import "Update";
    import "SpaceCalculation";
    import "Wizard";

    string backup_path = "";

    integer min_space = 50;

    //
    // Check, if the backup fits to disk
    //

    define boolean check_backup_path (list part_info) ``{

	boolean found = false;
	integer free_space = 0;

	if ( size ( backup_path ) <= 1 ||
	     substring(backup_path,0,1) != "/" )
	{
	    // error popup, user did not enter a valid directory specification
	    UI::MessagePopup( _("Invalid backup path.") );
	    return false;
	}

	foreach( `part, part_info, ``{

	    string part_name = part["name"]:"";

	    if ( part_name == "/" && !found )
	    {
		free_space = part["free"]:0;
		y2milestone("Partition :%1", part_name);
		y2milestone("free:%1", free_space );
	    }

	    if ( size ( backup_path ) >=2 && part_name != "/")
	    {
		string compare_string = substring ( backup_path, 0 , size ( part_name ) );
		if (compare_string == part_name && !found)
		{
		    free_space   = part["free"]:0;
		    y2milestone("Partition :%1", part_name );
		    y2milestone("free:%1", free_space );
		    found = true;
		}
		else
		{
		    y2milestone("Partition :%1<->%2", part_name, compare_string);
		}
	    }
	} );

	if (free_space >= min_space || Mode::test)
	{
	    return true;
	}
	else
	{
	    // there is not enough space for the backup during update
	    // inform the user about this (MB==megabytes)
	    string message = sformat ( _("Minimum disk space of %1 MB required."), min_space);
	    UI::MessagePopup (message);
	    return false;
	}
    };

    // ------------------------------------------------------------------------

    // get current backup path
    backup_path = Pkg::GetBackupPath();
    y2milestone("Current backup path is %1.", backup_path );

    // Get information about available partitions
    list partition = SpaceCalculation::GetPartitionInfo();
    y2milestone("evaluate partitions: %1", partition);

    // screen title for software selection
    string title = _("Backup System Before Update");

    // Build and show dialog

    Wizard::OpenAcceptDialog();

    term contents = `HVSquash(
			      `VBox(
				    `Left(`CheckBox(`id(`configs),`opt(`notify),
						    // checkbox label if user wants to backup config files before update
						    _("Create backup of changed configuration files"))),
				    `Left(`CheckBox(`id(`sysconfig),`opt(`notify),
						    // checkbox label if user wants to backup /etc/sysconfig
						    _("Create complete backup of /etc/sysconfig"))),
				    `Left(`CheckBox(`id(`remove),`opt(`notify),
						    // checkbox label if user wants remove old backup stuff
						    _("Remove old backups from backup directory"))),
				    `VSpacing(),
				    // label for text entry or backup path
				    `TextEntry(`id(`path), _("Backup path:"))
				    )
			     );

    string helptext = _("<p>
It is possible to make a <b>backup</b> of your existing system.
Please be aware that it will not be a complete backup. Only your
configuration files will be saved.
</p>
");

    Wizard::SetContents (title, contents, helptext, Args(0), Args(1));

    UI::ChangeWidget (`id(`configs), `Value, Update::backup_configs);
    UI::ChangeWidget (`id(`sysconfig), `Value, Update::backup_sysconfig);
    UI::ChangeWidget (`id(`remove), `Value, Update::remove_old_backups);

    UI::ChangeWidget (`id(`path), `Value, backup_path);
    UI::ChangeWidget (`id(`path), `Enabled, Update::backup_configs ||
		      Update::backup_sysconfig || Update::remove_old_backups);

    any ret = nil;

    while (true)
    {
	ret = Wizard::UserInput();

	if (ret == `abort && CallFunction (`inst_confirm_abort (`painless)))
	    break;

	if (ret == `cancel || ret == `back)
	    break;

	// any backup wanted?
	boolean tmp1 = UI::QueryWidget (`id(`configs), `Value) ||
	    UI::QueryWidget (`id(`sysconfig), `Value);

	// any backup or remove of old stuff wanted?
	boolean tmp2 = UI::QueryWidget (`id(`configs), `Value) ||
	    UI::QueryWidget (`id(`sysconfig), `Value) ||
	    UI::QueryWidget (`id(`remove), `Value);

	// backup path
	backup_path = UI::QueryWidget (`id(`path), `Value);

	// enable or disable path widget
	UI::ChangeWidget(`id(`path), `Enabled, tmp2);

	if (ret == `next)
	{
	    if (tmp1 && !check_backup_path (partition))
	    {
		UI::SetFocus (`id(`path));
		continue;
	    }

	    Update::backup_configs = UI::QueryWidget (`id(`configs), `Value);
	    Update::backup_sysconfig = UI::QueryWidget (`id(`sysconfig), `Value);
	    Update::remove_old_backups = UI::QueryWidget (`id(`remove), `Value);

	    // tell package manager about our plans
	    Pkg::CreateBackups (Update::backup_configs);
	    Pkg::SetBackupPath (backup_path);

	    // remember path for continue mode
	    SCR::Write (.target.string, Installation::destdir + "/var/lib/YaST2/backup_path", backup_path);

	    break;
	}
    }

    Wizard::CloseDialog ();

    return ret;
}

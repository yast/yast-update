/**
 * Module:	proposal_update.ycp
 *
 * Author:	Arvin Schnell <arvin@suse.de>
 *
 * Purpose:	Let user choose update settings.
 */
{
    textdomain "update";

    import "HTML";
    import "Update";
    import "Mode";

    string func  = WFM::Args(0);
    map    param = WFM::Args(1);
    map    ret   = $[];


    define void init_stuff () ``{

	// initialize target
	if (true)
	{
	    Pkg::TargetInit (Installation::destdir, false);
	}

	// initialize package manager
	if (true)
	{
	    UI::OpenDialog (`opt(`decorated ),
			    // intermediate popup while initializing internal packagemanagement
			    `Label(_("Reading package information. One moment please...")));
	    Packages::Init (true);
	    sleep (500);

	    UI::CloseDialog();
	}

	// connect target with package manager
	if (true)
	{
	    list tmp1 = Pkg::PkgUpdateAll (Update::deleteOldPackages);
	    Update::affected_count = tmp1[0]:0;
	    Update::unknown_count = tmp1[1]:0;

	    if (!Pkg::PkgSolve (!Update::onlyUpdateSelected))
		Update::unknown_count = Update::unknown_count + Pkg::PkgSolveErrors ();
	}
    }


    if ( func == "MakeProposal" )
    {
	boolean force_reset      = param["force_reset"     ]:false;
	boolean language_changed = param["language_changed"]:false;

	// call some function that makes a proposal here:
	//
	// DummyMod::MakeProposal( force_reset );

	// Fill return map

	init_stuff ();

	list tmp = [];

	tmp = add (tmp, _("Update to FIXME"));

	if (Update::onlyUpdateSelected)
	{
	    // Proposal for backup during update
	    tmp = add (tmp, _("Only update"));
	}
	else
	{
	    string selection = Update::GetSelection ();
	    map selection_data = Pkg::SelectionData (selection);
	    string selection_summary = selection_data["summary"]:"error";

	    // Proposal for backup during update
	    tmp = add (tmp, sformat (_("Update based on selection \"%1\""),
				     selection_summary));
	}

	if (Update::deleteOldPackages)
	{
	    // Proposal for backup during update
	    tmp = add (tmp, _("Delete old packages"));
	}

	ret = $[ "preformatted_proposal" :
		 HTML::List (tmp)
	];
    }
    else if ( func == "AskUser" )
    {
	boolean has_next = param["has_next"]:false;

	// call some function that displays a user dialog
	// or a sequence of dialogs here:
	//
	// sequence = DummyMod::AskUser( has_next );

	symbol result = WFM::CallFunction (`inst_update (true, has_next));

	// Fill return map

	ret = $[ "workflow_sequence" : result ];
    }
    else if ( func == "Description" )
    {
	// Fill return map.
	//
	// Static values do just nicely here, no need to call a function.

	ret =
	    $[
	      // this is a heading
	      "rich_text_title"	:	_( "Update options"  ),
	      // this is a menu entry
	      "menu_title"	:	_( "&Update options" ),
	      "id"		:	"update_stuff"
	    ];
    }

    return ret;
}

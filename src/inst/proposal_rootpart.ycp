/**
 * Module:	proposal_rootpart.ycp
 *
 * Author:	Arvin Schnell <arvin@suse.de>
 *
 * Purpose:	Let user choose root partition during update.
 */
{
    textdomain "update";

    import "HTML";
    import "Update";

    string func  = WFM::Args(0);
    map    param = WFM::Args(1);
    map    ret   = $[];

    if ( func == "MakeProposal" )
    {
	boolean force_reset      = param["force_reset"     ]:false;
	boolean language_changed = param["language_changed"]:false;

	// call some function that makes a proposal here:
	//
	// DummyMod::MakeProposal( force_reset );

	// Fill return map

	if (!Update::didSearchForRootPartitions || force_reset)
	{
	    UI::OpenDialog (`opt(`decorated ),
			    `Label(_("Evaluating root partition. One moment please...")));

	    Update::FindRootPartitions (force_reset);

	    UI::CloseDialog ();

	    Update::selectedRootPartition = "";
	}

	if (size (Update::validRootPartitions) == 0)
	{
	    ret = $[ "warning" :
		     // Proposal for system to update
		     _("No root partition found"),
		     "warning_level" : `blocker
	    ];
	}
	else
	{
	    if (Update::selectedRootPartition == "")
	    {
		if (size (Update::validRootPartitions) == 1)
		{
		    foreach (`p, `r, Update::validRootPartitions, ``{
			if (Update::selectedRootPartition == "")
			    Update::selectedRootPartition = p;
		    });
		}
		else
		{
		    symbol result = WFM::CallFunction (`inst_rootpart (true, true, `update_popup));
		}
	    }

	    if (size (Update::validRootPartitions) == 1)
	    {
		ret = $[ "raw_proposal" :
			 [ Update::validRootPartitions[Update::selectedRootPartition]:"error" ]
		];
	    }
	    else
	    {
		ret = $[ "raw_proposal" :
			 // Proposal for system to update
			 [ sformat (_("%1 on root partition %2"),
				    Update::validRootPartitions[Update::selectedRootPartition]:"error",
				    Update::selectedRootPartition) ]
		];
	    }
	}
    }
    else if ( func == "AskUser" )
    {
	boolean has_next = param["has_next"]:false;

	// call some function that displays a user dialog
	// or a sequence of dialogs here:
	//
	// sequence = DummyMod::AskUser( has_next );

	symbol result = WFM::CallFunction (`inst_rootpart (true, has_next, `update_dialog));

	// Fill return map

	ret = $[ "workflow_sequence" : result ];
    }
    else if ( func == "Description" )
    {
	// Fill return map.
	//
	// Static values do just nicely here, no need to call a function.

	ret =
	    $[
	      // this is a heading
	      "rich_text_title"	:	_( "Selected for update"  ),
	      // this is a menu entry
	      "menu_title"	:	_( "&Selected for update" ),
	      "id"		:	"rootpart_stuff"
	    ];
    }

    return ret;
}
